---
title: ""
author: ""
format: 
  revealjs:
    theme: dark
    slide-number: true
    self-contained: true
editor: visual
bibliography: book.bib
---

# Reproducible Research {background-color="#33431e"}

Jasper Slingsby

## The Reproducibility Crisis {background-color="#33431e"}

<br>

> *"**Replication** is the ultimate standard by which scientific claims are judged."* - @Peng2011

-   Replication is one of the fundamental tenets of science
-   Findings from studies that cannot be independently replicated should be treated with caution!
    -   Either they are not generalisable (cf. prediction) or worse, there was an error in the study!

## The Reproducibility Crisis {background-color="#33431e"}

Sadly, we have a problem...

!['Is there a reproducibility crisis?' - A survey of \>1500 scientists [@Baker2016; @Penny2016].](img/reprocrisis-1.png)

## Reproducible Research {background-color="#33431e"}

<br>

-   Makes use of modern software tools to share data, code, etc to allow others to reproduce the same result as the original study, thus ***making all analyses open and transparent**.*

    -   This is ***central to scientific progress!!!***

<br>

-   BONUS: working reproducibly ***facilitates automated workflows***, which is useful for applications like iterative near-term ecological forecasting!

<br>

## Replication vs Reproducibility {background-color="#33431e"}

<br>

-   ***Reproducibility*** falls short of full ***replication*** because it focuses on reproducing the same result ***from the same data set***, rather than analyzing independently collected data.

<br>

-   This difference may seem trivial, but you'd be surprised at how few studies are even reproducible, let alone replicable.

##  {.smaller background-color="#33431e"}

### Replication and the Reproducibility Spectrum

![](img/peng_reproducibility.jpg)

-   Full replication is a huge challenge, and sometimes impossible, e.g.
    -   rare phenomena, long term records, very expensive projects like space missions, etc
-   Where the "gold standard" of full replication cannot be achieved, we have to settle for a lower rung somewhere on ***The Reproducibility Spectrum*** [@Peng2011]

## Why work reproducibly? {.smaller background-color="#33431e"}

![Let's start being more specific about our miracles... Cartoon Â© Sidney Harris. Used with permission [ScienceCartoonsPlus.com](www.ScienceCartoonsPlus.com)](img/miracle.jpg)

## Why work reproducibly? {.smaller background-color="#33431e"}

<br>

> "*Five selfish reasons to work reproducibly*" [@Markowetz2015]

1.  Its ***transparent and open*** - helping avoid mistakes or track down errors
2.  It makes it ***easier to write papers*** - faster tracking of changes and manuscript updates
3.  It ***helps the review process*** - reviewers can actually see (and do!) what you did
4.  It ***enables continuity*** of research - simplifying project handover (esp. past to future you!)
5.  It builds ***reputation*** - showing integrity and gaining credit where your work is reused

## Why work reproducibly? {.smaller background-color="#33431e"}

<br>

Some less selfish reasons:

6.  It ***speeds scientific progress*** facilitating building on previous findings and analyses

7.  It ***allows easy comparison*** of new analytical approaches to older ones

8.  It makes it easy to ***repeat analyses on new data***, e.g. for ecological forecasting or LTER[^3_reproducibility-1]

9.  The tools are ***useful beyond research***, e.g. making websites, presentations

10. Reproducible research ***skills are highly sought after!***

-   Skills are important should you decide to leave science...
-   Within science, more and more environmental organizations and NGOs are hiring data scientists or scientists with strong data and quantitative skills

[^3_reproducibility-1]: Long Term Ecological Research studies that require frequent updates

## Barriers to working reproducibly {.smaller background-color="#33431e"}

From "A Beginner's Guide to Conducting Reproducible Research" [@Alston2021]:

<br>

### 1. Complexity

-   There's a *learning curve* in getting to know and use the tools effectively
    -   One is always tempted by the "easy option" of doing it the way you already know or using "user-friendly" proprietary software

### 2. Technological change

-   Hardware and software change over time, making it difficult to rerun old analyses
    -   This should be less of a problem as more tools like contained computing environments become available

## Barriers to working reproducibly {.smaller background-color="#33431e"}

<br>

### 3. Human error

-   Simple mistakes or poor documentation can easily make a study irreproducible.
    -   Most reproducible research tools are actually aimed at solving this problem!

### 4. Intellectual property rights

-   Rational self-interest can lead to hesitation to share data and code via many pathways:
    -   Fear of not getting credit; Concern that the materials shared will be used incorrectly or unethically; etc
    -   Hopefully most of these issues will be solved by better awareness of licensing issues, attribution, etc, as the culture of reproducible research grows

## Reproducible Scientific Workflows {.smaller background-color="#33431e"}

!['Data Pipeline' from [xkcd.com/2054](https://xkcd.com/2054), used under a [CC-BY-NC 2.5 license](https://creativecommons.org/licenses/by-nc/2.5/).](img/xkcd_data_pipeline_2x.png)

<br>

Working reproducibly requires careful planning and documentation of each step in your scientific workflow from *planning* your data collection to *sharing* your results.

## Reproducible Scientific Workflows {background-color="#33431e"}

Entail overlapping/intertwined components, namely:

1.  Data management
2.  File and folder management
3.  Coding and code management (data manipulation and analyses)
4.  Computing environment and software
5.  Sharing of the data, metadata, code, publications and any other relevant materials

## 1. Data management {background-color="#33431e"}

<br/>

This is a big topic and has a separate section in my notes.

<br/>

***Read the notes*** as this is NB information for you to know.

## 1. Data management {.smaller background-color="#33431e"}

Data loss is the norm... Good data management is key!!!

```{r datadecay, echo=FALSE, fig.cap = "The 'Data Decay Curve' [@Michener1997]", fig.width=3, fig.align = 'center', out.width="75%"}
knitr::include_graphics("img/datadecaycurve.jpg")
```

## 1. Data management {.smaller background-color="#33431e"}

```{r datalifecycle, echo=FALSE, fig.cap = "The Data Life Cycle, adapted from https://www.dataone.org/", fig.width=6, fig.align = 'center', out.width="100%"}
# load library
library(ggplot2)

# Create test data.
data <- data.frame(
  category=c("1.Plan", "2.Collect", "3.Assure", "4.Describe", "5.Preserve", "6.Discover", "7.Integrate", "8.Analyze"),
  count=rep(12.5, 8)
)
 
# Compute percentages
data$fraction <- data$count / sum(data$count)

# Compute the cumulative percentages (top of each rectangle)
data$ymax <- cumsum(data$fraction)

# Compute the bottom of each rectangle
data$ymin <- c(0, head(data$ymax, n=-1))

# Compute label position
data$labelPosition <- (data$ymax + data$ymin) / 2

# Compute a good label
data$label <- paste0(data$category, "\n value: ", data$count)

# Make the plot
ggplot(data, aes(ymax=ymax, ymin=ymin, xmax=4, xmin=3, fill=category)) +
  geom_rect() +
  geom_text(x=3.5, aes(y=labelPosition, label=category)) + #, color=category)) + # x here controls label position (inner / outer)
  scale_fill_brewer(palette="Blues") +
#  scale_color_brewer(palette="Blues", direction = -1) +
  coord_polar(theta="y") +
  xlim(c(2, 4.5)) +
  theme_void() +
  theme(legend.position = "none")
```

## Plan {.smaller background-color="#c2c190"}

Good data management begins with planning. You essentially **outline the plan for every step of the cycle in as much detail as possible**.

Fortunately, there are **online data management planning tools** that make it easy to develop a **Data Management Plan (DMP)**.

```{r uctdmp, echo=FALSE, fig.cap = "Screenshot of [UCT's Data Management Planning Tool's Data Management Checklist.](http://www.digitalservices.lib.uct.ac.za/dls/systems/uct-dmp)", fig.width=3, fig.align = 'center', out.width="90%"}
knitr::include_graphics("img/UCTDMP.png")
```

**A DMP is a living document and should be regularly revised during the life of a project!**

## Collect & Assure {.smaller background-color="#c2c190"}

I advocate that ***it is foolish to collect data without doing quality assurance and quality control (QA/QC) as you go***, irrespective of how you are collecting the data.

```{r appsheet, echo=FALSE, fig.cap = "An example data collection app I built in [AppSheet](https://www.appsheet.com) that allows you to log GPS coordinates, take photos, record various fields, etc.", fig.width=3, fig.align = 'center', out.width="80%"}
knitr::include_graphics("img/veldwatch.png")
```

There are many tools that allow you to do quality assurance and quality control as you collect the data (or progressively shortly after data collection events). See [**Epicollect**](https://five.epicollect.net/) or the [**QField**](https://qfield.org/) plug-in for QGIS. Even just MS Excel or GoogleSheets with controlled fields etc.

## Describe, Preserve, Discover {.smaller background-color="#c2c190"}


```{r fairdata, echo=FALSE, fig.cap = "The FAIR data principles [ErrantScience.com](https://errantscience.com/).", fig.width=3, fig.align = 'center', out.width="60%"}
knitr::include_graphics("img/fairdata.jpg")
```


## Describe {.smaller background-color="#c2c190"}

*Metadata* = descriptive data about the data

- the study context
  - why the data were collected, and when and where
  - who funded, created, collected, assured, managed and owns the data (not always the same person) - and their contact details
  - where the data are stored
- the data format
  - what is the file format and what software (and their versions) were used
- the data content
  - what was measured and how
  - what the columns and rows are and what units they're in
  - what QA/QC has been applied
  - etc

## Preserve {.smaller background-color="#c2c190"}

::::: columns
::: {.column width="50%"}

### Short term

***Back your data up now!!!*** 

***And now!!!***

Losing your data can be incredibly inconvenient!!! 

And incredibly expensive!!! 
- to you (extra years studying)
- to whoever pays for your study...

<br>

Check out [How Toy Story 2 Almost Got Deleted](https://www.youtube.com/watch?v=8dhp_20j0Ys).
:::

::: {.column width="50%"}

### Long term

**Global databases:**

-   [GenBank](https://www.ncbi.nlm.nih.gov/genbank/) - for molecular data
-   [TRY](https://www.try-db.org/TryWeb/Home.php) - for plant traits
-   [Dryad](https://datadryad.org) - for general biological and environmental data

**South African databases:**

-   [SANBI](https://www.sanbi.org/resources/infobases/) (biodiversity), [SAEON](https://catalogue.saeon.ac.za/) (environmental and biodiversity)

**"Generalist" repositories:**

-   [FigShare](https://figshare.com/) (incl. UCT's [ZivaHub](https://zivahub.uct.ac.za/)), [Zenodo](https://zenodo.org/)
:::
:::::

## Discover {.smaller background-color="#c2c190"}

::::: columns
::: {.column width="50%"}
Data that are not shared are effectively lost to science, and thus cannot be discovered or built upon by others.

Preserving your data in a well-known database with good metadata and a clear license allows others to discover and reuse your data, thus facilitating scientific progress. 

There are many license options like the [Creative Commons](https://creativecommons.org/licenses/) suite, which allow you to specify how your data can be used by others, while still giving you credit for your work. For software or code, there are other specific licenses like [MIT](https://opensource.org/licenses/MIT) or [GPL](https://www.gnu.org/licenses/gpl-3.0.en.html), but these are not usually used for data.

:::
::: {.column width="45%"}

**Creative Commons Licenses:**

- CCO = it is *Open* - i.e. no restrictions
- CC BY = *by attribution* 
- CC BY-SA = *by attribution* + *share alike* 
- CC BY-ND = *by attribution* + *no derivatives*
- CC BY-NC = *by attribution* + *non-commercial* 
- CC BY-NC-SA = *by attribution* + *non-commercial* + *share alike*
- CC BY-NC-ND - *by attribution* + *non-commercial* + *no derivatives*

:::
:::::

## Integrate & Analyse {.smaller background-color="#c2c190"}

"The fun bit", but again, there are many things to bear in mind and keep track of so that your analysis is repeatable. This is largely covered by the sections on *Coding and code management* and *Computing environment and software* below

![Artwork \@allison_horst](img/tidydata_5.jpg)

## 2. File and folder management {.smaller background-color="#33431e"}

::::: columns
::: {.column width="45%"}
!['Documents' from [xkcd.com/1459](https://xkcd.com/1459), used under a [CC-BY-NC 2.5 license](https://creativecommons.org/licenses/by-nc/2.5/).](img/documentnaming.png)
:::

::: {.column width="55%"}
<br>

Project files and folders can get unwieldy fast and really bog you down!

<br>

The main considerations are:

-   defining a simple, common, intuitive folder structure
-   using informative file names
-   version control where possible
    -   e.g. GitHub, Google Docs, etc
:::
:::::

##  {.smaller background-color="#c2c190"}

::::::: columns
::: {.column width="46%"}
### Folders

Most projects have similar requirements

Here's how I usually manage my folders:

![](img/gitrepofolders.png) <br>

-   "code"contains code for analyses
-   "data" often has separate "raw" and "processed" (or "clean") folders
    -   Large files (e.g. GIS) may be stored elsewhere
-   "output" contains figures and tables
:::

::: {.column width="4%"}
:::

:::: {.column width="50%"}
::: fragment
### Names should be

-   machine readable
    -   avoid spaces and funny punctuation
    -   support searching and splitting, e.g. "data_raw.csv", "data_clean.csv" can be searched by keywords and split into fields by "\_"
-   human readable
    -   contents self evident from the name
-   support sorting
    -   numeric or character prefixes separate files by component or step
    -   folder structure helps here too
:::
::::
:::::::

## 3. Coding and code management {.smaller background-color="#33431e"}

### Why write code?

"Point-and-click" software like Excel, Statistica, SPSS etc may seem easier, but you'll regret it in the long run... e.g. When you have to rerun or remember what you did?[^3_reproducibility-3]

<br>

::: fragment
### Coding rules

Coding is communication. Messy code is bad communication. Bad communication hampers collaboration and makes it easier to make mistakes...
:::

<br>

::: fragment
### Version control

[Streamline, collaborate, reuse, contribute, and fail safely...](https://www.openscapes.org/blog/2022/05/27/github-illustrated-series/)
:::

[^3_reproducibility-3]: Although to be fair many of these softwares now allow you to save what you did as a "macro" or similar


## Why write code? {.smaller background-color="#c2c190"}

::::: columns
::: {.column width="50%"}
![Artwork \@allison_horst](img/R_allisonhorst.png)
:::

::: {.column width="50%"}
"Point-and-click" software may seem easier, but you'll regret it in the long run... e.g. When you have to rerun your analysis?

-   Code is essential for reproducibility and automation.
-   While many software now allow you to save what you did as a script or "macro", but they are usually not open source and not easily shared or reused.

R, Python, etc are open source and allow you to do almost any analysis in one workflow - even calling other software.
:::
:::::

## Why write code? {.smaller background-color="#c2c190"}

-   **Automation** - reusing code is one click, and you're unlikely to introduce errors
-   A script provides a **record of your analysis**
-   **Uninterrupted workflows** - scientific coding languages like Python or R allow you to run almost any kind of analysis in one scripted workflow
    -   GIS, phylogenetics, multivariate or Bayesian statistics, etc
    -   saves you manually exporting and importing data between software
-   Most coding languages are **open source** (e.g. R, Python, JavaScript, etc)
    -   **Free!** No one has to pay to reuse any code you share
    -   **Transparent** - You (and others) can check the background code and functions you're using, not just the software company
    -   A **culture of sharing** code (online forums, with publications, etc)

## Some coding rules {.smaller background-color="#c2c190"}

It'seasytowritemessyindecipherablecode!!! - ***Write code for people, not computers!!!***

<br>

::: {.incremental}

Check out the [Tidyverse style guide](https://style.tidyverse.org/index.html) for R-specific guidance, but here are some basics:

-   use consistent, meaningful and distinct **names** for variables and functions
-   use consistent code and **formatting style** - indents, spaces, line-breaks, etc
-   **modularize code** into manageable steps/chunks
    -   or separate scripts that can be called in order from a master script or Makefile
    -   write **functions** rather than repeating the same code
-   use **commenting** to explain what you're doing at each step or in each function
    -   "notebooks" like RMarkdown, Quarto, Jupyter or Sweave allow embedded code, simplifying documentation, master/Makefiles, etc and can be used to write manuscripts, presentations or websites (e.g. all my teaching materials)
-   **check for mistakes** at every step!!! Do the outputs make sense?

:::

## Some coding rules continued... {.smaller background-color="#c2c190"}

-   start with a "**recipe**"
    -   outline the steps/modules before you start coding to keep you on track
    -   e.g. a common recipe in R (using commented headers):

```{r, echo = T}
#Header indicating purpose, author, date, version etc

#Define settings and load required libraries

#Read in data

#Wrangle/reformat/clean/summarize data as required

#Run analyses (often multiple steps)

#Wrangle/reformat/summarize analysis outputs for visualization

#Visualize outputs as figures or tables
```

-   avoid proprietary formats! i.e. use **open source** scripting languages and file formats
-   use version control!!!

## Version control {.smaller background-color="#c2c190"}

Version control tools can be challenging , but also hugely simplify your workflow!

The advantages of version control[^1]:

[^1]: `Terminology` for Git and [GitHub](https://github.com/), but most have similar functions.

:::::: columns
::: {.column width="15%"}
![](img/octicons-mark-github.svg)
:::

:::: {.column width="85%"}
::: incremental
-   They generally help project management, especially **collaborations**
-   They allow **easy code sharing** with collaborators or the public at large - through `repositories` ("repos") or `gists` (code snippets)
-   The **system is online**, but you **can also work offline** by `cloning` the repo to your local PC. You can "`push` to" or "`pull` from" the online repo to keep versions in sync
-   **Changes are tracked and reversible** through `commits`
    -   Changes must be `commit`ed with a `commit message` - creating a recoverable `version` that can be `compared` or `reverted`
    -   **Version control** magically frees you from duplicated files!
:::
::::
::::::

## Version control continued... {.smaller background-color="#c2c190"}

-   Users can easily **adapt or build on each others' code** by `forking` repos and working on their own `branch`.
    -   This allows you to **repeat/replicate analyses** or even build websites (like this one!)

::: {.incremental}
-   Collaborators can **propose changes** via `pull requests`
    -   Repo `owners` can **accept and integrate changes seamlessly** by `review` and `merge` the *forked branch* back to the `main` branch
    -   Comments associated with `commit` or `pull request`s provide a **written record of changes** and track the user, date, time, etc - all of which and are useful tracking mistakes and `blaming` when things go wrong
-   You can `assign`, log and track `issues` and `feature requests`

:::

## Version control - example workflow {.smaller background-color="#c2c190"}

![](img/GitDiagram.drawio.png)

## Version control - example workflow {.smaller background-color="#c2c190"}

![](img/git_paircoding.png)

Interestingly, since all that's tracked are the _commits_, whereby versions are named (the nodes in the image). All that the online Git repo records is this figure below. The black is the the OWNER's _main_ branch and the blue is the COLLABORATOR's _fork_.


## Version control in pretty pictures {.smaller background-color="#c2c190"}

![Artwork by \@allison_horst [CC-BY-4.0](https://github.com/allisonhorst/stats-illustrations/blob/main/license)](img/git_commit.png)

## Version control in pretty pictures {.smaller background-color="#c2c190"}

![Artwork by \@allison_horst [CC-BY-4.0](https://github.com/allisonhorst/stats-illustrations/blob/main/license)](img/git_navigate.png)

## 4. Computing environment {background-color="#33431e"}

<br>

Sharing your code and data is not enough to maintain reproducibility...

***Software and hardware change between users, with upgrades, versions or user community preferences!***

-   You'll all know MicroSoft Excel, but have you heard of Quattro Pro or Lotus that were the preferred spreadsheet software of yesteryear?

## The lazy solution {.smaller background-color="#c2c190"}

You can document the hardware and versions of software used so that others can recreate that computing environment if needed.

-   In R, you can simply run the `sessionInfo()` function, giving details below
-   This just makes it someone else's problem to recreate your computing environment (usually you!), which is not ideal...

```{r}
sessionInfo()
```

## A better solution {.smaller background-color="#c2c190"}

If your entire workflow is within R, you can use the [renv](https://rstudio.github.io/renv/) package to manage your R environment.

::::: columns
::: {.column width="15%"}
![](img/renv.svg)
:::

::: {.column width="85%"}
`renv` is essentially a package manager.

It creates a **snapshot** of your R environment, including all packages and their versions, so that anyone can recreate the same environment by running `renv::restore()`

<br>

Disadvantages are that it doesn't manage for:

-   Different versions of R
-   Different operating systems
-   Software outside of R (e.g. JAGS, Stan, Python, GitHub etc)
:::
:::::

## The best solution? {.smaller background-color="#c2c190"}

Use **containers** like those provided by software like [docker](https://www.docker.com/) or [singularity](https://sylabs.io/singularity/).

::::: columns
::: {.column width="15%"}
![](img/docker.png)

<br>

<br>

<br>

![](img/rocker.png)
:::

::: {.column width="85%"}
Containers provide "images" of contained, lightweight computing environments that you can package with your software/workflow to set up [virtual machines](https://en.wikipedia.org/wiki/Virtual_machine) with all the necessary software and settings etc.

You set your container up to have everything you need to run your workflow (and nothing extra), so anyone can download (or clone) your container, code and data and run your analyses perfectly every time.

Containers are usually based on Linux, because other operating systems are not free.

The [Rocker project](https://www.rocker-project.org/) provides a set of Docker images for R and RStudio, which are widely used in the R community.
:::
:::::

## 5. Sharing data, code, publication etc {.smaller background-color="#33431e"}

:::::: columns
::: {.column width="50%"}
This is covered by data management, but suffice to say there's no point working reproducibly if you're not going to share all the components necessary to complete your workflow...

<br>

Another key component here is that ideally all your data, code, publication etc are shared *Open Access*

-   not stuck behind some paywall!
-   not in a proprietary format or requiring proprietary software
-   shared with a permissive use license
    -   e.g. [Creative Commons](https://creativecommons.org/licenses/)
:::

::: {.column width="5%"}
:::

::: {.column width="45%"}
![A 3-step, 10-point checklist to guide researchers toward greater reproducibility [@Alston2021].](img/alstonreproducibility.jpg)
:::
::::::

::::

## Automation? {.smaller background-color="#33431e"}

The key to iterating your workflow, especially for forecasting.

Many options!

::: incremental
-   **Makefiles** - a simple text file that defines how to run your code, e.g. in R, Python, etc
-   **RMarkdown** or **Quarto** - allow you to write code and text in the same document, which can be run to produce a report, website, etc
-   **GitHub Actions** - allows you to automate workflows in GitHub, e.g. running tests, building documentation, etc
-   **R** - R has many packages for automating workflows, e.g. [`targets`](https://docs.ropensci.org/targets/)
:::

## An example {.smaller background-color="#33431e"}

![](img/emma_logo.jpg)

The project aims to develop a near-real-time satellite change detection system for the Fynbos Biome using an ecological forecasting approach ([www.emma.eco](www.emma.eco)).

## An example {.smaller background-color="#33431e"}

![](img/emma_nasa.png){fig-align="center"}

## EMMA Workflow {.smaller background-color="#c2c190"}

::::: columns
::: {.column width="30%"}
![](img/emma_workflow.png)
:::

::: {.column width="70%"}
<br>

The workflow is designed to be run on a weekly basis, with new data ingested and processed automatically.

There are several steps, each of which is run automatically:

-   **Data ingest** - new data is downloaded from various APIs
-   **Data processing** - to extract the relevant info and reformat for analysis
-   **Data analysis** - the data is analysed to detect changes in the environment
-   **Data visualization and sharing** - via a Quarto website run from a GitHub repository
:::
:::::

## EMMA Workflow {.smaller background-color="#c2c190"}

::::: columns
::: {.column width="12%"}
![](img/quarto.png)

![](img/Rlogo.png){width="80%"} ![](img/targets_logo.png){width="80%"}

![](img/github_actions.webp){width="80%"} ![](img/docker.png){width="80%"}

![](img/octicons-mark-github.svg){width="80%"}
:::

::: {.column width="85%"}
Outputs a `Quarto` website, automatically built from a GitHub repository.

<br>

Processing and analysis done in R. Intermediate and final outputs stored as GitHub releases or in GitHub Large File Storage.

<br>

R workflow managed by the `targets` package

<br>

`GitHub Actions` used to automate and run the workflow

<br>

`Docker` container sets up the computing environment

<br>

All code, data, metadata, etc are shared on `GitHub`
:::
:::::

## EMMA `targets` Workflow {.smaller background-color="#c2c190"}

::::: columns
::: {.column width="40%"}
![Example `targets` workflow from https://wlandau.github.io/targets-tutorial/#8](img/targets_pipeline_graph.png){width="100%"}

![EMMA targets workflow](img/emma_targets.png)
:::

::: {.column width="60%"}
`targets` is an R package that allows you to define a workflow as a series of steps, each of which can be run automatically.

<br>

The package identifies which steps are out of date and runs them and their dependencies, but ignores unaffected steps, saving computation.

<br>

In EMMA, the workflow is defined as a series of R scripts, which is run automatically by GitHub Actions on a weekly basis, triggered by a GitHub runner. `targets` keeps track and controls which steps have been run and which need to be rerun depending on new data inputs, etc.
:::
:::::

## Unit testing {background-color="#33431e"}

-   A key component of automation is **unit testing**
    -   testing each component of your code to ensure it works as expected
-   This is a part of general coding and code management, but is especially important for forecasting, where you need to ensure that your code runs correctly on new data
-   R has many packages for unit testing, e.g. [`testthat`](https://testthat.r-lib.org/) and [`RUnit`](https://cran.r-project.org/web/packages/RUnit/index.html)


## References {.smaller background-color="#33431e"}
